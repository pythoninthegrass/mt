//! FFI wrapper for Zig signature generation.
//!
//! This module provides a safe Rust interface to the Zig-based
//! Last.fm API signature generation.

use std::collections::BTreeMap;
use std::ffi::CString;
use std::os::raw::c_char;

use mt_core::ffi;

/// Generate Last.fm API signature using Zig FFI
///
/// The signature is generated by:
/// 1. Sorting all parameters alphabetically by key (excluding 'format')
/// 2. Concatenating them as "key1value1key2value2..."
/// 3. Appending the API secret
/// 4. Computing MD5 hash and converting to lowercase hex
///
/// This uses the Zig implementation for the actual computation.
pub fn sign_params_ffi(params: &BTreeMap<String, String>, api_secret: &str) -> Option<String> {
    // Filter out 'format' parameter and collect key-value pairs
    let filtered: Vec<(&String, &String)> = params
        .iter()
        .filter(|(k, _)| k.as_str() != "format")
        .collect();

    if filtered.is_empty() && api_secret.is_empty() {
        return None;
    }

    // Build C string pairs array
    let mut c_strings: Vec<CString> = Vec::with_capacity(filtered.len() * 2);
    let mut c_ptrs: Vec<*const c_char> = Vec::with_capacity(filtered.len() * 2);

    for (key, value) in &filtered {
        let key_cstr = CString::new(key.as_str()).ok()?;
        let value_cstr = CString::new(value.as_str()).ok()?;
        c_strings.push(key_cstr);
        c_strings.push(value_cstr);
    }

    // Get pointers (after all CStrings are created to avoid invalidation)
    for cstr in &c_strings {
        c_ptrs.push(cstr.as_ptr());
    }

    let api_secret_cstr = CString::new(api_secret).ok()?;
    let mut out_sig = [0u8; 32];

    let success = unsafe {
        ffi::mt_lastfm_generate_signature(
            c_ptrs.as_ptr(),
            filtered.len() as u32,
            api_secret_cstr.as_ptr(),
            out_sig.as_mut_ptr(),
        )
    };

    if success {
        // Convert bytes to string (it's already ASCII hex)
        Some(String::from_utf8_lossy(&out_sig).to_string())
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sign_params_ffi_basic() {
        let mut params = BTreeMap::new();
        params.insert("method".to_string(), "auth.getToken".to_string());
        params.insert("api_key".to_string(), "test_key".to_string());

        let api_secret = "test_secret";
        let signature = sign_params_ffi(&params, api_secret);

        // Expected: md5("api_keytest_keymethodauth.getTokentest_secret")
        // Should match the Rust-only implementation
        assert!(signature.is_some());
        let sig = signature.unwrap();
        assert_eq!(sig.len(), 32);
        assert_eq!(sig, "6cfa1f81f85e59104673832f2a555441");
    }

    #[test]
    fn test_sign_params_ffi_excludes_format() {
        let mut params = BTreeMap::new();
        params.insert("method".to_string(), "auth.getToken".to_string());
        params.insert("api_key".to_string(), "test_key".to_string());
        params.insert("format".to_string(), "json".to_string());

        let api_secret = "test_secret";
        let signature = sign_params_ffi(&params, api_secret);

        // Should be identical to test without format parameter
        assert!(signature.is_some());
        assert_eq!(signature.unwrap(), "6cfa1f81f85e59104673832f2a555441");
    }

    #[test]
    fn test_sign_params_ffi_sorted_order() {
        let mut params = BTreeMap::new();
        // Insert in non-alphabetical order to verify sorting
        params.insert("track".to_string(), "Test Track".to_string());
        params.insert("artist".to_string(), "Test Artist".to_string());
        params.insert("method".to_string(), "track.scrobble".to_string());
        params.insert("api_key".to_string(), "abc123".to_string());

        let api_secret = "secret123";
        let signature = sign_params_ffi(&params, api_secret);

        // Expected: md5("api_keyabc123artistTest Artistmethodtrack.scrobbletrackTest Tracksecret123")
        assert!(signature.is_some());
        assert_eq!(signature.unwrap(), "096846546dbe116e83f2ceb679892045");
    }

    #[test]
    fn test_sign_params_ffi_with_session_key() {
        let mut params = BTreeMap::new();
        params.insert("method".to_string(), "track.scrobble".to_string());
        params.insert("api_key".to_string(), "test_key".to_string());
        params.insert("sk".to_string(), "session_key_123".to_string());
        params.insert("artist".to_string(), "Artist Name".to_string());
        params.insert("track".to_string(), "Track Name".to_string());
        params.insert("timestamp".to_string(), "1234567890".to_string());

        let api_secret = "test_secret";
        let signature = sign_params_ffi(&params, api_secret);

        // Verified against Python's hashlib.md5
        assert!(signature.is_some());
        assert_eq!(signature.unwrap(), "c28d80ed34429217b843d790ea55d9ca");
    }

    #[test]
    fn test_sign_params_ffi_empty_params() {
        let params = BTreeMap::new();
        let api_secret = "test_secret";
        let signature = sign_params_ffi(&params, api_secret);

        // Empty params with secret should still generate a signature
        // md5("test_secret")
        assert!(signature.is_some());
    }

    #[test]
    fn test_sign_params_ffi_matches_rust_impl() {
        use crate::lastfm::signature::sign_params;

        let mut params = BTreeMap::new();
        params.insert("method".to_string(), "track.scrobble".to_string());
        params.insert("api_key".to_string(), "test_key".to_string());
        params.insert("artist".to_string(), "Test Artist".to_string());
        params.insert("track".to_string(), "Test Track".to_string());
        params.insert("timestamp".to_string(), "1234567890".to_string());

        let api_secret = "test_secret";

        // Both implementations should produce identical results
        let rust_sig = sign_params(&params, api_secret);
        let zig_sig = sign_params_ffi(&params, api_secret).unwrap();

        assert_eq!(rust_sig, zig_sig);
    }
}
