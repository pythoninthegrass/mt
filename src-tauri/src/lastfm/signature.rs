use std::collections::BTreeMap;

/// Generate Last.fm API signature using MD5 hash
///
/// The signature is generated by:
/// 1. Sorting all parameters alphabetically by key (excluding 'format')
/// 2. Concatenating them as "key1value1key2value2..."
/// 3. Appending the API secret
/// 4. Computing MD5 hash and converting to lowercase hex
///
/// This implementation must match the Python version byte-for-byte.
pub fn sign_params(params: &BTreeMap<String, String>, api_secret: &str) -> String {
    // Build signature string: key1value1key2value2...secret
    let mut signature_string = String::new();

    for (key, value) in params.iter() {
        // Skip 'format' parameter as per Last.fm API requirements
        if key == "format" {
            continue;
        }
        signature_string.push_str(key);
        signature_string.push_str(value);
    }

    signature_string.push_str(api_secret);

    // Compute MD5 hash
    let digest = md5::compute(signature_string.as_bytes());

    // Convert to lowercase hex string
    format!("{:x}", digest)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::BTreeMap;

    #[test]
    fn test_sign_params_basic() {
        let mut params = BTreeMap::new();
        params.insert("method".to_string(), "auth.getToken".to_string());
        params.insert("api_key".to_string(), "test_key".to_string());

        let api_secret = "test_secret";
        let signature = sign_params(&params, api_secret);

        // Expected: md5("api_keytest_keymethodauth.getTokentest_secret")
        // Verified against Python's hashlib.md5
        let expected = "6cfa1f81f85e59104673832f2a555441";
        assert_eq!(signature, expected);
    }

    #[test]
    fn test_sign_params_excludes_format() {
        let mut params = BTreeMap::new();
        params.insert("method".to_string(), "auth.getToken".to_string());
        params.insert("api_key".to_string(), "test_key".to_string());
        params.insert("format".to_string(), "json".to_string());

        let api_secret = "test_secret";
        let signature = sign_params(&params, api_secret);

        // Should be identical to test without format parameter
        let expected = "6cfa1f81f85e59104673832f2a555441";
        assert_eq!(signature, expected);
    }

    #[test]
    fn test_sign_params_sorted_order() {
        let mut params = BTreeMap::new();
        // Insert in non-alphabetical order to verify sorting
        params.insert("track".to_string(), "Test Track".to_string());
        params.insert("artist".to_string(), "Test Artist".to_string());
        params.insert("method".to_string(), "track.scrobble".to_string());
        params.insert("api_key".to_string(), "abc123".to_string());

        let api_secret = "secret123";
        let signature = sign_params(&params, api_secret);

        // Expected: md5("api_keyabc123artistTest Artistmethodtrack.scrobbletrackTest Tracksecret123")
        // Verified against Python's hashlib.md5
        let expected = "096846546dbe116e83f2ceb679892045";
        assert_eq!(signature, expected);
    }

    #[test]
    fn test_sign_params_with_session_key() {
        let mut params = BTreeMap::new();
        params.insert("method".to_string(), "track.scrobble".to_string());
        params.insert("api_key".to_string(), "test_key".to_string());
        params.insert("sk".to_string(), "session_key_123".to_string());
        params.insert("artist".to_string(), "Artist Name".to_string());
        params.insert("track".to_string(), "Track Name".to_string());
        params.insert("timestamp".to_string(), "1234567890".to_string());

        let api_secret = "test_secret";
        let signature = sign_params(&params, api_secret);

        // Verified against Python's hashlib.md5
        let expected = "c28d80ed34429217b843d790ea55d9ca";
        assert_eq!(signature, expected);
    }
}
